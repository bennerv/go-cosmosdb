// Code generated by github.com/jim-minter/go-cosmosdb, DO NOT EDIT.

package cosmosdb

import (
	"context"
	"fmt"
	"net/http"
	"sync"

	"github.com/ugorji/go/codec"

	pkg "github.com/jim-minter/go-cosmosdb/example/types"
)

type fakePersonTriggerHandler func(context.Context, *pkg.Person) error
type fakePersonQueryHandler func(PersonClient, *Query, *Options) PersonRawIterator

var _ PersonClient = &FakePersonClient{}

func NewFakePersonClient(h *codec.JsonHandle) *FakePersonClient {
	return &FakePersonClient{
		people:       make(map[string][]byte),
		triggerHandlers: make(map[string]fakePersonTriggerHandler),
		queryHandlers:   make(map[string]fakePersonQueryHandler),
		jsonHandle:      h,
		lock:            &sync.RWMutex{},
	}
}

type FakePersonClient struct {
	people       map[string][]byte
	jsonHandle      *codec.JsonHandle
	lock            *sync.RWMutex
	triggerHandlers map[string]fakePersonTriggerHandler
	queryHandlers   map[string]fakePersonQueryHandler
	sorter          func([]*pkg.Person)

	// returns true if documents conflict
	conflictChecker func(*pkg.Person, *pkg.Person) bool

	// err, if not nil, is an error to return when attempting to communicate
	// with this Client
	err error
}

func (c *FakePersonClient) decodePerson(s []byte) (person *pkg.Person, err error) {
	err = codec.NewDecoderBytes(s, c.jsonHandle).Decode(&person)
	return
}

func (c *FakePersonClient) encodePerson(person *pkg.Person) (b []byte, err error) {
	err = codec.NewEncoderBytes(&b, c.jsonHandle).Encode(person)
	return
}

func (c *FakePersonClient) SetError(err error) {
	c.lock.Lock()
	defer c.lock.Unlock()
	c.err = err
}

func (c *FakePersonClient) SetSorter(sorter func([]*pkg.Person)) {
	c.lock.Lock()
	defer c.lock.Unlock()

	c.sorter = sorter
}

func (c *FakePersonClient) SetConflictChecker(conflictChecker func(*pkg.Person, *pkg.Person) bool) {
	c.lock.Lock()
	defer c.lock.Unlock()

	c.conflictChecker = conflictChecker
}

func (c *FakePersonClient) SetTriggerHandler(triggerName string, trigger fakePersonTriggerHandler) {
	c.lock.Lock()
	defer c.lock.Unlock()

	c.triggerHandlers[triggerName] = trigger
}

func (c *FakePersonClient) SetQueryHandler(queryName string, query fakePersonQueryHandler) {
	c.lock.Lock()
	defer c.lock.Unlock()

	c.queryHandlers[queryName] = query
}

func (c *FakePersonClient) encodeAndCopy(person *pkg.Person) (*pkg.Person, []byte, error) {
	b, err := c.encodePerson(person)
	if err != nil {
		return nil, nil, err
	}
	personCopy, err := c.decodePerson(b)
	if err != nil {
		return nil, nil, err
	}
	return personCopy, b, err
}

func (c *FakePersonClient) apply(ctx context.Context, partitionkey string, person *pkg.Person, options *Options, isCreate bool) (*pkg.Person, error) {
	c.lock.Lock()
	defer c.lock.Unlock()

	if c.err != nil {
		return nil, c.err
	}

	if options != nil {
		err := c.processPreTriggers(ctx, person, options)
		if err != nil {
			return nil, err
		}
	}

	personCopy, b, err := c.encodeAndCopy(person)
	if err != nil {
		return nil, err
	}

	_, exists := c.people[person.ID]
	if isCreate && exists {
		return nil, &Error{
			StatusCode: http.StatusConflict,
			Message:    "Entity with the specified id already exists in the system",
		}
	}
	if !isCreate && !exists {
		return nil, &Error{StatusCode: http.StatusNotFound}
	}

	if c.conflictChecker != nil {
		for id := range c.people {
			personToCheck, err := c.decodePerson(c.people[id])
			if err != nil {
				return nil, err
			}

			if c.conflictChecker(personToCheck, personCopy) {
				return nil, &Error{
					StatusCode: http.StatusConflict,
					Message:    "Entity with the specified id already exists in the system",
				}
			}
		}
	}

	c.people[person.ID] = b
	return personCopy, nil
}

func (c *FakePersonClient) Create(ctx context.Context, partitionkey string, person *pkg.Person, options *Options) (*pkg.Person, error) {
	return c.apply(ctx, partitionkey, person, options, true)
}

func (c *FakePersonClient) Replace(ctx context.Context, partitionkey string, person *pkg.Person, options *Options) (*pkg.Person, error) {
	return c.apply(ctx, partitionkey, person, options, false)
}

func (c *FakePersonClient) List(*Options) PersonIterator {
	c.lock.RLock()
	defer c.lock.RUnlock()

	if c.err != nil {
		return NewFakePersonErroringRawIterator(c.err)
	}

	people := make([]*pkg.Person, 0, len(c.people))
	for _, d := range c.people {
		r, err := c.decodePerson(d)
		if err != nil {
			return NewFakePersonErroringRawIterator(err)
		}
		people = append(people, r)
	}

	if c.sorter != nil {
		c.sorter(people)
	}

	return NewFakePersonIterator(people, 0)
}

func (c *FakePersonClient) ListAll(ctx context.Context, options *Options) (*pkg.People, error) {
	iter := c.List(options)
	return iter.Next(ctx, -1)
}

func (c *FakePersonClient) Get(ctx context.Context, partitionkey string, id string, options *Options) (*pkg.Person, error) {
	c.lock.RLock()
	defer c.lock.RUnlock()

	if c.err != nil {
		return nil, c.err
	}

	person, exists := c.people[id]
	if !exists {
		return nil, &Error{StatusCode: http.StatusNotFound}
	}
	return c.decodePerson(person)
}

func (c *FakePersonClient) Delete(ctx context.Context, partitionKey string, person *pkg.Person, options *Options) error {
	c.lock.Lock()
	defer c.lock.Unlock()

	if c.err != nil {
		return c.err
	}

	_, exists := c.people[person.ID]
	if !exists {
		return &Error{StatusCode: http.StatusNotFound}
	}

	delete(c.people, person.ID)
	return nil
}

func (c *FakePersonClient) ChangeFeed(*Options) PersonIterator {
	c.lock.RLock()
	defer c.lock.RUnlock()

	if c.err != nil {
		return NewFakePersonErroringRawIterator(c.err)
	}
	return NewFakePersonErroringRawIterator(ErrNotImplemented)
}

func (c *FakePersonClient) processPreTriggers(ctx context.Context, person *pkg.Person, options *Options) error {
	for _, triggerName := range options.PreTriggers {
		if triggerHandler := c.triggerHandlers[triggerName]; triggerHandler != nil {
			err := triggerHandler(ctx, person)
			if err != nil {
				return err
			}
		} else {
			return ErrNotImplemented
		}
	}
	return nil
}

func (c *FakePersonClient) Query(name string, query *Query, options *Options) PersonRawIterator {
	c.lock.RLock()
	defer c.lock.RUnlock()

	if c.err != nil {
		return NewFakePersonErroringRawIterator(c.err)
	}

	if queryHandler := c.queryHandlers[query.Query]; queryHandler != nil {
		return queryHandler(c, query, options)
	} else {
		return NewFakePersonErroringRawIterator(ErrNotImplemented)
	}
}

func (c *FakePersonClient) QueryAll(ctx context.Context, partitionkey string, query *Query, options *Options) (*pkg.People, error) {
	iter := c.Query("", query, options)
	return iter.Next(ctx, -1)
}

// NewFakePersonIterator creates a PersonIterator that will produce
// only People from Next().
func NewFakePersonIterator(people []*pkg.Person, continuation int) PersonIterator {
	return &fakePersonIterator{people: people, continuation: continuation}
}

type fakePersonIterator struct {
	people    []*pkg.Person
	continuation int
	done         bool
}

func (i *fakePersonIterator) Next(ctx context.Context, maxItemCount int) (*pkg.People, error) {
	if i.done {
		return nil, nil
	}

	var people []*pkg.Person
	if maxItemCount == -1 {
		people = i.people[i.continuation:]
		i.continuation = len(i.people)
		i.done = true
	} else {
		max := i.continuation + maxItemCount
		if max > len(i.people) {
			max = len(i.people)
		}
		people = i.people[i.continuation:max]
		i.continuation += max
		i.done = i.Continuation() == ""
	}

	return &pkg.People{
		People: people,
		Count:     len(people),
	}, nil
}

func (i *fakePersonIterator) Continuation() string {
	if i.continuation >= len(i.people) {
		return ""
	}
	return fmt.Sprintf("%d", i.continuation)
}

func NewFakePersonErroringRawIterator(err error) *fakePersonErroringRawIterator {
	return &fakePersonErroringRawIterator{err: err}
}

// fakePersonErroringRawIterator is a RawIterator that will return an error on
// use.
type fakePersonErroringRawIterator struct {
	err error
}

func (i *fakePersonErroringRawIterator) Next(ctx context.Context, maxItemCount int) (*pkg.People, error) {
	return nil, i.err
}

func (i *fakePersonErroringRawIterator) NextRaw(context.Context, int, interface{}) error {
	return i.err
}

func (i *fakePersonErroringRawIterator) Continuation() string {
	return ""
}
